# Экзамен.Servlet

## Оглавление

1. [Что такое сервлет?](#1-Что-такое-сервлет)
2. [Какова структура веб-проекта?](#2-Какова-структура-веб-проекта)
3. [Что такое контейнер сервлетов?](#3-Что-такое-контейнер-сервлетов)
4. [Каковы задачи, функциональность контейнера сервлетов?](#4-Каковы-задачи-функциональность-контейнера-сервлетов)
5. [Что вы знаете о сервлет фильтрах?](#5-Что-вы-знаете-о-сервлет-фильтрах)
6. [Зачем нужны слушатели в сервлетах?](#6-Зачем-нужны-слушатели-в-сервлетах)
7. [Когда вы будете использовать фильтры, а когда слушатели?](#7-Когда-вы-будете-использовать-фильтры-а-когда-слушатели)
8. [Как обработать исключения, выброшенные другим сервлетом в приложении?](#8-Как-обработать-исключения-выброшенные-другим-сервлетом-в-приложении)
9. [Что такое дескриптор развертывания?](#9-Что-такое-дескриптор-развертывания)
10. [Как реализовать запуск сервлета с запуском приложения?](#10-Как-реализовать-запуск-сервлета-с-запуском-приложения)
11. [Что представляет собой объект ServletConfig?](#11-Что-представляет-собой-объект-ServletConfig)
12. [Что представляет собой объект ServletContext?](#12-Что-представляет-собой-объект-ServletContext)
13. [В чем отличия ServletContext и ServletConfig?](#13-В-чем-отличия-ServletContext-и-ServletConfig)
14. [Что такое Request Dispatcher?](#14-Что-такое-Request-Dispatcher)
15. [Как можно создать блокировку (deadlock) в сервлете?](#15-Как-можно-создать-блокировку-deadlock-в-сервлете)
16. [Как получить адрес сервлета на сервере?](#16-Как-получить-адрес-сервлета-на-сервере)
17. [Как получить информацию о сервере из сервлета?](#17-Как-получить-информацию-о-сервере-из-сервлета)
18. [Как получить ip адрес клиента на сервере?](#18-Как-получить-ip-адрес-клиента-на-сервере?)
19. [Что вы знаете о классах обертках (wrapper) для сервлетов?](#19-Что-вы-знаете-о-классах-обертках-wrapper-для-сервлетов)
20. [Каков жизненный цикл сервлета и когда какие методы вызываются?](#20-Каков-жизненный-цикл-сервлета-и-когда-какие-методы-вызываются)
21. [Какие методы необходимо определить при создании сервлетов?](#21-Какие-методы-необходимо-определить-при-создании-сервлетов)
22. [В каком случае вы будете переопределять метод service()?](#22-В-каком-случае-вы-будете-переопределять-метод-service)
23. [Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?](#23-Есть-ли-смысл-определить-конструктор-для-сервлета-как-лучше-инициализировать-данные)
24. [В чем отличия GenericServlet и HttpServlet?](#24-В-чем-отличия-GenericServlet-и-HttpServlet)
25. [Как вызвать из сервлета другой сервлет этого же и другого приложения?](#25-Как-вызвать-из-сервлета-другой-сервлет-этого-же-и-другого-приложения)
26. [Что вы знаете и в чем отличия методов forward() и sendRedirect()?](#26-Что-вы-знаете-и-в-чем-отличия-методов-forward-и-sendRedirect)
27. [Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?](#27-Стоит-ли-волноваться-о-многопоточной-безопасности-работая-с-сервлетами)
28. [В чем отличие между веб сервером и сервером приложений?](#28-В-чем-отличие-между-веб-сервером-и-сервером-приложений)
29. [Какой метод HTTP не является неизменяемым?](#29-Какой-метод-HTTP-не-является-неизменяемым)
30. [Почему HttpServlet класс объявлен как абстрактный?](#30-Почему-HttpServlet-класс-объявлен-как-абстрактный)
31. [В чем разница между методами GET и POST?](#31-В-чем-разница-между-методами-GET-и-POST)
32. [Что такое MIME-тип?](#32-Что-такое-MIME-тип)
33. [Назовите преимущества Servlet над CGI?](#33-Назовите-преимущества-Servlet-над-CGI)
34. [Каковы наиболее распространенные задачи выполняются в Servlet контейнере?](#34-Каковы-наиболее-распространенные-задачи-выполняются-в-Servlet-контейнере)
35. [В чем разница между PrintWriter и ServletOutputStream?](#35-В-чем-разница-между-PrintWriter-и-ServletOutputStream)
36. [Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?](#36-Можем-ли-мы-получить-PrintWriter-и-ServletOutputStream-одновременно-в-сервлете)
37. [Расскажите о интерфейсе SingleThreadModel.](#37-Расскажите-о-интерфейсе-SingleThreadModel)
38. [Какие существуют атрибуты у сервлетов и какая сфера их применения?](#38-Какие-существуют-атрибуты-у-сервлетов-и-какая-сфера-их-применения)
39. [Почему необходимо переопределить только init() метод без аргументов?](#39-Почему-необходимо-переопределить-только-init()-метод-без-аргументов)
40. [Что означает URL encoding? Зачем нужны методы java.net.URLEncoder.encode() и decode()?](#40-Что-означает-URL-encoding-Зачем-нужны-методы-java-net-URLEncoder-encode-и-decode)
41. [Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?](#41-Зачем-нужны-и-чем-отличаются-методы-encodeUrl-и-encodeRedirectUrl)
42. [Какие различные методы управления сессией в сервлетах вы знаете?](#42-Какие-различные-методы-управления-сессией-в-сервлетах-вы-знаете)
43. [Что означает URL Rewriting?](#43-Что-означает-URL-Rewriting)
44. [Как применяются Cookies в сервлетах?](#45-Как-применяются-Cookies-в-сервлетах)
45. [Как уведомить объект в сессии, что сессия недействительна или закончилась?](#45-Как-уведомить-объект-в-сессии-что-сессия-недействительна-или-закончилась)
46. [Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?](#46-Какой-существует-эффективный-способ-удостоверится-что-все-сервлеты-доступны-только-для-пользователя-с-валидной-сессией)
47. [Как мы можем обеспечить transport layer security для нашего веб приложения?](#47-Как-мы-можем-обеспечить-transport-layer-security-для-нашего-веб-приложения)
48. [Как организовать подключение к базе дынных и обеспечить логирование log4j в сервлете?](#48-Как-организовать-подключение-к-базе-дынных-и-обеспечить-логирование-log4j-в-сервлете)
49. [Какие важные особенности существуют в Servlet 3?](#49-Какие-важные-особенности-существуют-в-Servlet-3)
50. [Каковы различные способы аутентификации сервлета?](#50-Каковы-различные-способы-аутентификации-сервлета)
51. [Написать сервлет, реализующий загрузку файла на сервер.](#51-Написать-сервлет-реализующий-загрузку-файла-на-сервер)

## 1 Что такое сервлет?

Serlvet - это интерфейс, при реализации которого расширяются функциональные возможности сервера. Serlvet позволяет
обработать запрос клиента и отправить ему ответ. Обычно сервлеты используются в веб-приложениях. Для таких приложений
технология Java Servlet определяет HTTP-специфичные сервлет-классы. Пакеты javax.servlet и javax.servlet.http
обеспечивают интерфейсы и классы для создания сервлетов.

[К оглавлению &#8593;](#Оглавление)

## 2 Какова структура веб-проекта?

[К оглавлению &#8593;](#Оглавление)

## 3 Что такое контейнер сервлетов?

Контейнер сервлетов — программа, представляющая собой сервер, который занимается системной поддержкой сервлетов и
обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях.

Известные реализации:Apache Tomcat, Jetty, JBoss, GlassFish, IBM WebSphere, Oracle Weblogic

[К оглавлению &#8593;](#Оглавление)

## 4 Каковы задачи, функциональность контейнера сервлетов?

Контейнер сервлетов может работать как полноценный самостоятельный веб-сервер, быть поставщиком страниц для другого
веб-сервера, например Apache, или интегрироваться в Java EE сервер приложений. Обеспечивает обмен данными между
сервлетом и клиентами, берёт на себя выполнение таких функций, как создание программной среды для функционирующего
сервлета, идентификацию и авторизацию клиентов, организацию сессии для каждого из них.

[К оглавлению &#8593;](#Оглавление)

## 5 Что вы знаете о сервлет фильтрах?

Сервлетный фильтр, в соответствии со спецификацией, это Java-код, пригодный для повторного использования и позволяющий
преобразовать содержание HTTP-запросов, HTTP-ответов и информацию, содержащуюся в заголовках HTTP. Сервлетный фильтр
занимается предварительной обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа,
исходящего из сервлета.Сервлетные фильтры могут:

- перехватывать инициализацию сервлета прежде, чем сервлет будет инициирован;
- определить содержание запроса прежде, чем сервлет будет инициирован;
- модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;
- модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ; — перехватывать инициализацию
  сервлета после обращения к сервлету.

Сервлетный фильтр может быть сконфигурирован так, что он будет работать с одним сервлетом или группой сервлетов. Основой
для формирования фильтров служит интерфейс javax.servlet.Filter, который реализует три метода:

- **void init (FilterConfig config) throws ServletException**;
- **void destroy()**;
- **void doFilter (ServletRequest request, ServletResponse response, FilterChain chain) throws IOException,
  ServletException**;

Метод init() вызывается прежде, чем фильтр начинает работать,и настраивает конфигурационный объект фильтра. Метод
doFilter выполняет непосредственно работу фильтра. Таким образом, сервер вызывает init() один раз, чтобы запустить
фильтр в работу, а затем вызывает doFilter() столько раз, сколько запросов будет сделано непосредственно к данному
фильтру. После того как фильтр заканчивает свою работу, вызывается метод destroy().

[К оглавлению &#8593;](#Оглавление)

## 6 Зачем нужны слушатели в сервлетах?

Слушатели контекста и сессий — это классы, которые могут следить за тем, когда контекст или сессия были
инициализированы, или отслеживать время, когда они должны быть уничтожены, и когда атрибуты были добавлены или удалены
из контекста или сессии. Servlet 2.4 расширяет модель слушателей запроса, позволяя отслеживать, как запрос создается и
уничтожается, и, как атрибуты добавляются и удаляются из сервлета. В Servlet 2.4 добавлены следующие классы:

ServletRequestListener ServletRequestEvent ServletRequestAttributeListener ServletRequestAttributeEvent

[К оглавлению &#8593;](#Оглавление)

## 7 Когда вы будете использовать фильтры, а когда слушатели?

[К оглавлению &#8593;](#Оглавление)

## 8 Как обработать исключения, выброшенные другим сервлетом в приложении?

[К оглавлению &#8593;](#Оглавление)

## 9 Что такое дескриптор развертывания?

Дескриптор развертывания — это конфигурационный файл артефакта, который будет развернут в контейнере сервлетов. В
спецификации Java Platform, Enterprise Edition дескриптор развертывания описывает то, как компонент, модуль или
приложение (такое, как веб-приложение или приложение предприятия) должно быть развернуто.

Этот конфигурационный файл указывает параметры развертывания для модуля или приложения с определенными настройками,
параметры безопасности и описывает конкретные требования к конфигурации. Для синтаксиса файлов дескриптора развертывания
используется язык XML.

[К оглавлению &#8593;](#Оглавление)

## 10 Как реализовать запуск сервлета с запуском приложения?

Контейнер сервлетов обычно загружает сервлет при первом запросе клиента, но иногда необходимо загрузить сервлет прямо на
старте приложения (например если сервлет объемный и будет долго грузиться). Для этого необходимо использовать элемент
load-on-startup в дескрипторе (или аннотацию loadOnStartup), который укажет необходимость загрузки сервлета при запуске.

<servlet>
    <servlet-name>foo</servlet-name>
    <servlet-class>com.foo.servlets.Foo</servlet-class>
    <load-on-startup>5</load-on-startup>
</servlet>
Значение должно быть int. Если значение отрицательное, то сервлет будет загружен при запросе клиента, а если 0 и далее, то загрузится на старте приложения. Чем меньше число, тем раньше в очереди на загрузку будет сервлет.

[К оглавлению &#8593;](#Оглавление)

## 11 Что представляет собой объект ServletConfig?

Интерфейс javax.servlet.ServletConfig используется для передачи конфигурационной информации сервлету. Каждый сервлет
имеет свой собственный объект ServletConfig, за создание экземпляра которого ответственен контейнер сервлетов. Для
установки параметров конфигурации используются init параметры в web.xml (или аннотации WebInitParam). Для получения
объекта ServletConfig данного сервлета используется метод getServletConfig().

[К оглавлению &#8593;](#Оглавление)

## 12 Что представляет собой объект ServletContext?

Интерфейс javax.servlet.ServletContext предоставляет доступ к параметрам веб приложения сервлету. Объект ServletContext
является уникальным и доступен всем сервлетам веб приложения. Мы можем использовать объект ServletContext, когда нам
необходимо предоставить доступ одному или нескольким сервлетам к инициализированным параметрам веб приложения. Для этого
используется элемент <context-param> в web.xml. Объект ServletContext можно получить с помощью метода
getServletContext() у интерфейса ServletConfig. Контейнеры сервлетов так же могут предоставлять context объекты,
уникальные для группы сервлетов. Каждая из групп будет связана со своим набором URL путей хоста. ServletContext был
расширен в спецификации Servlet 3 и предоставляет программное добавление слушателей и фильтров в приложение. Так же у
этого интерфейса имеются множество полезных методов вроде getMimeType(), getResourceAsStream() и т.д..

[К оглавлению &#8593;](#Оглавление)

## 13 В чем отличия ServletContext и ServletConfig?

ServletConfig является уникальным объектом для каждого сервлета, в то время как ServletContext уникальный для всего
приложения. ServletConfig используется для предоставления параметров инициализации сервлету, а ServletContext для
предоставления параметров инициализации приложения для всех сервлетов. У нас нет возможности устанавливать атрибуты в
объекте ServletConfig, в то время как можно установить атрибуты в объекте ServletContext, которые будут доступны другим
сервлетам.

[К оглавлению &#8593;](#Оглавление)

## 14 Что такое Request Dispatcher?

Интерфейс RequestDispatcher используется для передачи запроса другому ресурсу (это может быть HTML, JSP или другой
сервлет в том же приложении). Мы можем использовать это для добавления контента другого ресурса к ответу. Этот интерфейс
используется для внутренней коммуникации между сервлетами в одном контексте. В интерфейсе реализовано два метода:
void forward(ServletRequest var1, ServletResponse var2) — передает запрос из сервлета к другому ресурсу (сервлету, JSP
или HTML файлу) на сервере. void include(ServletRequest var1, ServletResponse var2) — включает контент ресурса (сервлет,
JSP или HTML страница) в ответ. Доступ к интерфейсу можно получить с помощью метода ServletContext getRequestDispatcher(
String s). Путь должен начинаться с / , который будет интерпретироваться относительным текущего корневого пути
контекста.

[К оглавлению &#8593;](#Оглавление)

## 15 Как можно создать блокировку (deadlock) в сервлете?

deadlock можно получить с помощью зацикленного вызова метода. Например, вызвать метод doPost() в методе doGet() и
вызвать doGet() в методе doPost().

[К оглавлению &#8593;](#Оглавление)

## 16 Как получить адрес сервлета на сервере?

Для получения актуального пути сервлета на сервере можно использовать следующую конструкцию:
getServletContext().getRealPath(request.getServletPath())

[К оглавлению &#8593;](#Оглавление)

## 17 Как получить информацию о сервере из сервлета?

Информацию о сервере можно получить с использованием объекта ServletContext с помощью метода getServerInfo():  
getServletContext().getServerInfo().

[К оглавлению &#8593;](#Оглавление)

## 18 Как получить ip адрес клиента на сервере?

Для получения ip клиента в сервлете нужно использовать request.getRemoteAddr()

[К оглавлению &#8593;](#Оглавление)

## 19 Что вы знаете о классах обертках (wrapper) для сервлетов?

В Servlet HTTP API предоставляются два класса обертки — **HttpServletRequestWrapper** и **HttpServletResponseWrapper**.
Они помогают разработчикам реализовывать собственные реализации типов request и response сервлета. Мы можем расширить
эти классы и переопределить только необходимые методы для реализации собственных типов объектов ответов и запросов. Эти
классы не используются в стандартном программировании сервлетов.

[К оглавлению &#8593;](#Оглавление)

## 20 Каков жизненный цикл сервлета и когда какие методы вызываются?

Контейнер сервлетов управляет четырьмя фазами жизненного цикла сервлета:

- Загрузка класса сервлета: контейнер получает запрос для сервлета, происходит загрузка класса сервлета в память и вызов
  конструктора без параметров.
- Инициализация класса сервлета — после того как класс загружен в контейнер, контейнер инициализирует объект
  ServletConfig для этого сервлета и внедряет его через init() метод. Это и есть место, где сервлет класс преобразуется
  из обычного класса в сервлет.
- Обработка запросов — после инициализации сервлет готов к обработке запросов. Для каждого запроса клиента сервлет
  контейнер порождает новую нить (поток) и вызывает метод service() путем передачи ссылки на объект ответа и запроса.
- Удаление из Service — когда контейнер останавливается или останавливается приложение, то контейнер сервлетов
  уничтожает классы сервлетов путем вызова destroy() метода.

Можно описать как последовательность вызова методов: init(), service(), destroy().

- public void init(ServletConfig config) – используется контейнером для инициализации сервлета. Вызывается один раз за
  время жизни сервлета.
- public void service(ServletRequest request, ServletResponse response) – вызывается для каждого запроса. Метод не может
  быть вызван раньше выполнения init() метода.
- public void destroy() – вызывается для уничтожения сервлета (один раз за время жизни сервлета).

[К оглавлению &#8593;](#Оглавление)

## 21 Какие методы необходимо определить при создании сервлетов?

Чтобы создать сервлет, необходимо создать класс с нужным названием, затем расширить класс сервлета от класса HttpServlet
и реализовать метод service() или doGet(), doPost() (или первый или вторые).

[К оглавлению &#8593;](#Оглавление)

## 22 В каком случае вы будете переопределять метод service()?

Метод service() переопределяется, когда мы хотим, чтобы сервлет обрабатывал как GET, так и POST запросы в одном методе.
Когда контейнер сервлетов получает запрос клиента, то происходит вызов метода service(), который в свою очередь вызывает
doGet(), doPost() методы, основанные на HTTP методе запроса.

[К оглавлению &#8593;](#Оглавление)

## 23 Есть ли смысл определить конструктор для сервлета, как лучше инициализировать данные?

Такая возможность есть, но считается бессмысленной. Инициализировать данные лучше переопределив метод init(), в котором
получить доступ к параметрам инициализации сервлета через использование объекта ServletConfig.
[К оглавлению &#8593;](#Оглавление)

## 24 В чем отличия GenericServlet и HttpServlet?

Абстрактный класс GenericServlet — независимая от используемого протокола реализация интерфейса Servlet. HttpServlet,
как понятно из названия, реализация интерфейса сервлета для протокола HTTP. Следует отметить, что HttpServlet extends
GenericServlet.

[К оглавлению &#8593;](#Оглавление)

## 25 Как вызвать из сервлета другой сервлет этого же и другого приложения?

Если необходимо вызывать сервлет из того же приложения, то необходимо использовать механизм внутренней коммуникации
сервлетов (inter-servlet communication mechanisms). Мы можем вызвать другой сервлет с помощью RequestDispatcher
forward() и include() методов для доступа к дополнительным атрибутам в запросе для использования в другом сервлете.
Метод forward() используется для передачи обработки запроса в другой сервлет. Метод include() используется, если мы
хотим вложить результат работы другого сервлета в возвращаемый ответ.

Если необходимо вызывать сервлет из другого приложения, то использовать RequestDispatcher уже не получится (определен
для приложения). Поэтому можно использовать ServletResponse sendRedirect() метод и предоставить полный URL из другого
сервлета. Для передачи данных можно использовать cookies как часть ответа сервлета, а потом использовать их в нашем
сервлете.

[К оглавлению &#8593;](#Оглавление)

## 26 Что вы знаете и в чем отличия методов forward() и sendRedirect()?

RequestDispatcher forward() используется для проброски того же самого запроса к другому ресурсу, в то время как
ServletResponse sendRedirect() - это двухшаговый метод. Во методе sendRedirect() веб приложение возвращает ответ клиенту
с status code 302 (redirect) со ссылкой для отправки запроса. Запрос посылает полностью новый запрос.

forward() обрабатывается внутри контейнера, а sendRedirect() обрабатывается браузером. Необходимо использовать forward()
для организации доступа внутри одного и того же приложения, т.к. он быстрее sendRedirect(), которому требуется
дополнительная сетевая работа. В методе forward() браузер не знает о фактически обрабатываемом ресурсе и URL в строке
остается прежним. В sendRedirect() методе URL адрес изменяется на пробрасываемый ресурс. В методе forward() нельзя
использовать для внедрения сервлета в другой контекст. Для этого можно использовать только sendRedirect().

[К оглавлению &#8593;](#Оглавление)

## 27 Стоит ли волноваться о “многопоточной безопасности” работая с сервлетами?

Методы класса HTTPServlet init() и destroy() вызываются один раз за жизненный цикл сервлета — поэтому по поводу них
беспокоиться не стоит. Методы doGet(), doPost() вызываются на каждый запрос клиента, и т.к. сервлеты используют
многопоточность, то здесь нужно задумываться о потокобезопасной работе.

В случае наличия локальных переменных в этих методах нет необходимости думать о многопоточной безопасности, т.к. они
будут созданы отдельно для каждой нити. Но если используются глобальные ресурсы, то необходимо использовать
синхронизацию, как и в любом многопоточном приложении Java.

[К оглавлению &#8593;](#Оглавление)

## 28 В чем отличие между веб сервером и сервером приложений?

Веб сервер необходим для обработки HTTP request от браузера клиента и ответа клиенту с помощью HTTP response. Веб сервер
понимает язык HTTP и запускается по HTTP протоколу. Примером веб сервера может служить реализация от Apache — Tomcat.

Сервер приложений предоставляет дополнительные возможности, такие как поддержка JavaBeans, JMS Messaging, Transaction
Management и др. Можно сказать, что сервер приложений — это веб сервер с дополнительными возможностями, которые помогают
разрабатывать корпоративные приложения.

[К оглавлению &#8593;](#Оглавление)

## 29 Какой метод HTTP не является неизменяемым?

HTTP метод неизменяем, если он всегда возвращает одинаковый результат. HTTP методы GET, PUT, DELETE, HEAD, OPTIONS
являются неизменяемыми. Необходимо реализовывать приложение так, чтобы эти методы возвращали одинаковый результат. К
изменяемым методам относится HTTP метод POST. Post метод используется для реализации чего-либо, что изменяется при
каждом запросе.

К примеру, для доступа к HTML странице или изображению необходимо использовать метод GET, т.к. он возвращает одинаковый
результат. Но если нам необходимо сохранить информацию о заказе в базе данных, то нужно использовать POST метод.
Неизменяемые методы так же известны как безопасные методы и нет необходимости заботиться о повторяющихся запросах от
клиента для этих методов.

[К оглавлению &#8593;](#Оглавление)

## 30 Почему HttpServlet класс объявлен как абстрактный?

Класс HTTPServlet предоставляет реализацию HTTP протокола сервлета, но он не имеет реализованных методов doGet() и
doPost() (у них по умолчанию возвращение HTTP 405 Method Not Implemented error), а следовательно, объявлен абстрактным.
Реализация этих методов перекладывается на разработчика.

[К оглавлению &#8593;](#Оглавление)

## 31 В чем разница между методами GET и POST?

+ Метод GET - неизменяемый, POST - изменяемый.
+ С помощью метода GET можно посылать ограниченное кол-во данных, которые будут пересланы в заголовке URL. В случае POST
  метода мы можем пересылать большие объемы данных, т.к. они будут находиться в теле метода.
+ Данные GET метода передаются в открытом виде, что может использоваться в зловредных целях. POST данные передаются в
  теле запроса и скрыты от пользователя.
+ GET метод является HTTP методом по умолчанию, а POST метод необходимо указывать явно, чтобы отправить запрос. GET
  метод используется гиперссылками на странице.

[К оглавлению &#8593;](#Оглавление)

## 32 Что такое MIME-тип?

[К оглавлению &#8593;](#Оглавление)

## 33 Назовите преимущества Servlet над CGI?

[К оглавлению &#8593;](#Оглавление)

## 34 Каковы наиболее распространенные задачи выполняются в Servlet контейнере?

[К оглавлению &#8593;](#Оглавление)

## 35 В чем разница между PrintWriter и ServletOutputStream?

[К оглавлению &#8593;](#Оглавление)

## 36 Можем ли мы получить PrintWriter и ServletOutputStream одновременно в сервлете?

Мы не можем создать два объекта этих классов в одном сервлете. При попытке внедрить оба метода getWriter() и
getOutputStream() в ответе, мы получим исключение java.lang.IllegalStateException с сообщением, что уже другой метод был
вызван для этого ответа.

[К оглавлению &#8593;](#Оглавление)

## 37 Расскажите о интерфейсе SingleThreadModel.

[К оглавлению &#8593;](#Оглавление)

## 38 Какие существуют атрибуты у сервлетов и какая сфера их применения?

Атрибуты сервлетов ипользуются для внутренней коммуникации сервлетов. Мы можем использовать атрибуты set, get, remove в
веб-приложении. Существует три области видимости атрибутов — request scope, session scope, application scope.

Интерфейсы ServletRequest, HttpSession и ServletContext предоставляют методы для get(), set(), remove() атрибутов из
request scope, session scope, application scope соответственно.

[К оглавлению &#8593;](#Оглавление)

## 39 Почему необходимо переопределить только init() метод без аргументов?

[К оглавлению &#8593;](#Оглавление)

## 40 Что означает URL encoding? Зачем нужны методы java.net.URLEncoder.encode() и decode()?

URL Encoding — процесс преобразования данных в форму CGI (Common Gateway Interface), который позволит путешествовать по
сети без проблем. URL Encoding разделяет пробелы и заменяет специальные символы с помощью escape-симолов. Например, для
кодирования строки используется метод java.net.URLEncoder.encode(String str, String unicode). Обратная операция
декодирования возможна благодаря методу java.net.URLDecoder.decode(String str, String unicode). Пример работы метода:
строка «Java for study .ru» будет преобразована в Java%20for%20study%20.ru.

[К оглавлению &#8593;](#Оглавление)

## 41 Зачем нужны и чем отличаются методы encodeUrl() и encodeRedirectUrl()?

HttpServletResponse предоставляет методы преобразования URL в HTML гиперссылки с преобразованием спец символов и
пробелов, а так же добавления session id к URL. Такое поведение аналогично URLEncoder encode(), но с добавлением
дополнительного параметра jsessionid в конец URL.

Метод HttpServletResponse encodeRedirectUrl() применяется для преобразования redirect URL в ответе. Таким образом при
предоставлении поддержки URL rewriting для HTML гиперссылок необходимо использовать encodeURL(), а для редирект URL’ов
использовать encodeRedirectUrl().

[К оглавлению &#8593;](#Оглавление)

## 42 Какие различные методы управления сессией в сервлетах вы знаете?

Сессия является обычным состоянием взаимодействия сервера и клиента и может содержать в себе множество запросов и
ответов клиент-сервер. Т.к. HTTP и веб сервер не запоминают состояния (stateless), то единственным способом поддерживать
сессию является пересылка уникальной информации (session id) в каждом запросе и ответе между клиентом и сервером.

Существуют несколько распространенных способов управления сессией в сервлетах:

+ Аутентификация пользователя
+ HTML hidden field (скрытое поле)
+ Cookies
+ URL Rewriting
+ Session Management API

[К оглавлению &#8593;](#Оглавление)

## 43 Что означает URL Rewriting?

Для управления сессией в сервлетах мы можем использовать HTTPSession, но он работает с Cookies, а их иногда отключают.
Для этого случая в сервлетах предусмотрена возможность URL Rewriting. С точки зрения программирования необходимо всего
одно действие — кодирование URL. Другим достоинством является то, что этот метод является как бы запасным и включается
только при выключенных куках.

Применяя метод HttpServletResponse encodeURL() мы можем закодировать URL. Если необходим редирект к другому ресурсу, то
для предоставления информации о сессии применяется метод encodeRedirectURL().

[К оглавлению &#8593;](#Оглавление)

## 44 Как применяются Cookies в сервлетах?

Для работы с Cookies сервлеты могут использовать класс javax.servlet.http.Cookie. Для создания Cookie надо создать
объект этого класса с помощью конструктора Cookie(String name, String value), где *name* - ключ, а *value* - значение,
которое сохраняется в Cookies. Стоит отметить, что в Cookies можно сохранить только строки.

Чтобы добавить Cookie в ответ клиенту, у объекта HttpServletResponse применяется метод **addCookie(Cookie c)**, однако
не существует геттера для этого типа передачи данных.

Для получения массива cookies из запроса необходимо воспользоваться методом HttpServletRequest getCookies(). Для
добавления cookies в запрос методов не предусмотрено.

[К оглавлению &#8593;](#Оглавление)

## 45 Как уведомить объект в сессии, что сессия недействительна или закончилась?

Чтобы быть уверенным об оповещении объекта о прекращении сессии, объект должен реализовывать интерфейс
javax.servlet.http.HttpSessionBindingListener. Два метода этого интерфейса: **valueBound()** и **valueUnbound()**
применяются для реализации логики при добавлении объекта в качестве атрибута к сессии и при уничтожении сессии.

[К оглавлению &#8593;](#Оглавление)

## 46 Какой существует эффективный способ удостоверится, что все сервлеты доступны только для пользователя с валидной сессией?

Сервлет-фильтры используются для перехвата всех запросов между контейнером сервлетов и сервлетом. Поэтому логично
использовать фильтр для проверки необходимой информации (например, валидности сессии) в запросе.

[К оглавлению &#8593;](#Оглавление)

## 47 Как мы можем обеспечить transport layer security для нашего веб приложения?

Для этого необходимо настроить SSL для вашего сервлет-контейнера. Подробнее о настройке SSL описано в мануалах для
конкретной реализации контейнера.

[К оглавлению &#8593;](#Оглавление)

## 48 Как организовать подключение к базе дынных и обеспечить логирование log4j в сервлете?

При работе с большим количеством подключений к базе данных рекомендуется инициализировать их в servlet context listener
и установить в качестве атрибута контекста для возможности использования другими сервлетами. Логирование Log4j
подключается с помощью конфигурации XML (или файла property) и далее эта информация используется при конфигурировании
context listener’а.

[К оглавлению &#8593;](#Оглавление)

## 49 Какие важные особенности существуют в Servlet 3?

- Servlet Annotations. До Servlet 3 весь маппинг был в web.xml, что приводило к ошибкам и банально было неудобным при
  большом количестве сервлетов. Примеры аннотаций:  @WebServlet, @WebInitParam, @WebFilter, @WebListener.
- Web Fragments. С появлением веб-фрагментов мы можем содержать множество модулей в одностраничном веб-приложении. Все
  модули прописываются в fragment.xml в META-INF директории. Это позволяет разделять веб-приложение на отдельные модули,
  включенные как JAR файлы в отдельной lib директории.
- Динамическое добавление веб компонентов. Используя ServletContext объект, мы можем программно добавлять фильтры и
  слушатели. Это помогает построить динамическую систему, в которой необходимый объект будет вызван только по
  необходимости. Для этого применяются методы addServlet(), addFilter(), addListener().
- Асинхронное выполнение. Поддержка асинхронной обработки позволяет передать выполнение запроса в другой поток без
  удержания всего сервера занятым.

[К оглавлению &#8593;](#Оглавление)

## 50 Каковы различные способы аутентификации сервлета?

Контейнер сервлетов предоставляет различные способы аутентификации:

+ HTTP Basic Authentication
+ HTTP Digest Authentication
+ HTTPS Authentication Form Based Login

[К оглавлению &#8593;](#Оглавление)

## 51 Написать сервлет, реализующий загрузку файла на сервер.

[К оглавлению &#8593;](#Оглавление)